<template>
  <div class="planning-page">
    <!-- Header -->
    <div class="bg-white rounded-lg shadow-md p-6 mb-6">
      <div class="flex items-center justify-between">
        <div>
          <h1 class="text-2xl font-bold text-gray-900">üìÖ Planning Management</h1>
          <p class="text-gray-600 mt-1">Generate and manage work assignments for Pokemon card orders</p>
        </div>
        <div class="flex space-x-3">
          <button
            @click="testPlanningEndpoints"
            class="btn-secondary"
          >
            üîç Debug API
          </button>
          <button
            @click="refreshData"
            :disabled="loading"
            class="btn-primary"
          >
            {{ loading ? '‚è≥ Loading...' : 'üîÑ Refresh' }}
          </button>
        </div>
      </div>
    </div>

    <!-- Statistics Cards -->
    <div class="grid grid-cols-1 md:grid-cols-4 gap-6 mb-6">
      <div class="card">
        <div class="flex items-center">
          <div class="bg-blue-500 rounded-lg p-3 mr-4">
            <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v10a2 2 0 002 2h8a2 2 0 002-2V9a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01"></path>
            </svg>
          </div>
          <div>
            <p class="text-sm text-gray-600">Total Orders</p>
            <p class="text-2xl font-semibold text-gray-900">{{ stats.totalOrders }}</p>
          </div>
        </div>
      </div>

      <div class="card">
        <div class="flex items-center">
          <div class="bg-green-500 rounded-lg p-3 mr-4">
            <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </div>
          <div>
            <p class="text-sm text-gray-600">Planned Orders</p>
            <p class="text-2xl font-semibold text-gray-900">{{ stats.plannedOrders }}</p>
          </div>
        </div>
      </div>

      <div class="card">
        <div class="flex items-center">
          <div class="bg-orange-500 rounded-lg p-3 mr-4">
            <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </div>
          <div>
            <p class="text-sm text-gray-600">Employees Used</p>
            <p class="text-2xl font-semibold text-gray-900">{{ stats.employeeCount }}</p>
          </div>
        </div>
      </div>

      <div class="card">
        <div class="flex items-center">
          <div class="bg-purple-500 rounded-lg p-3 mr-4">
            <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path>
            </svg>
          </div>
          <div>
            <p class="text-sm text-gray-600">Total Plannings</p>
            <p class="text-2xl font-semibold text-gray-900">{{ plannings.length }}</p>
            <p v-if="duplicateStats.totalDuplicates > 0" class="text-xs text-red-600">
              ‚ö†Ô∏è {{ duplicateStats.totalDuplicates }} duplicates
            </p>
          </div>
        </div>
      </div>
    </div>

    <!-- Planning Configuration -->
    <div class="bg-white rounded-lg shadow-md p-6 mb-6">
      <h2 class="text-lg font-semibold text-gray-900 mb-4">Planning Configuration</h2>
      <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-2">Start Date</label>
          <input
            v-model="config.startDate"
            type="date"
            class="input-field"
            :min="minDate"
          >
        </div>
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-2">Time per Card (minutes)</label>
          <input
            v-model.number="config.cardProcessingTime"
            type="number"
            min="1"
            max="10"
            class="input-field"
          >
          <p class="text-xs text-gray-500 mt-1">Current: {{ CARD_PROCESSING_TIME }}min (from config)</p>
        </div>
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-2">Priority Mode</label>
          <select v-model="config.priorityMode" class="input-field">
            <option value="urgent">Urgent First</option>
            <option value="balanced">Balanced</option>
            <option value="efficiency">Efficiency First</option>
          </select>
        </div>
      </div>

      <!-- Options -->
      <div class="mt-4 flex items-center space-x-6">
        <label class="flex items-center">
          <input
            v-model="config.redistributeOverload"
            type="checkbox"
            class="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
          >
          <span class="ml-2 text-sm text-gray-700">Redistribute overload</span>
        </label>
        <label class="flex items-center">
          <input
            v-model="config.respectPriorities"
            type="checkbox"
            class="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
          >
          <span class="ml-2 text-sm text-gray-700">Respect priorities</span>
        </label>
      </div>

      <!-- Action Buttons -->
      <div class="mt-6 flex space-x-3">
        <button
          @click="generatePlanning"
          :disabled="generating"
          class="btn-primary"
        >
          {{ generating ? '‚è≥ Generating...' : 'üöÄ Generate Planning' }}
        </button>
        <button
          @click="optimizePlanning"
          :disabled="optimizing"
          class="btn-secondary"
        >
          {{ optimizing ? '‚è≥ Optimizing...' : '‚ö° Optimize Planning' }}
        </button>
        <button
          @click="cleanupData"
          class="bg-red-600 text-white px-4 py-2 rounded-lg hover:bg-red-700"
        >
          üóëÔ∏è Clean Up
        </button>
        <button
          @click="removeDuplicates"
          class="bg-purple-600 text-white px-4 py-2 rounded-lg hover:bg-purple-700"
        >
          üßπ Remove Duplicates
        </button>
      </div>
    </div>

    <!-- Plannings List -->
    <div v-if="plannings.length > 0" class="bg-white rounded-lg shadow-md overflow-hidden">
      <div class="px-6 py-4 border-b border-gray-200">
        <h2 class="text-lg font-semibold text-gray-900">Current Plannings</h2>
      </div>

      <div class="overflow-x-auto">
        <table class="min-w-full divide-y divide-gray-200">
          <thead class="bg-gray-50">
          <tr>
            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Date</th>
            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Employee</th>
            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Order</th>
            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Time</th>
            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Duration</th>
            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Status</th>
            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Actions</th>
          </tr>
          </thead>
          <tbody class="bg-white divide-y divide-gray-200">
          <tr
            v-for="planning in groupedPlannings"
            :key="planning.id"
            :class="[
                'hover:bg-gray-50',
                planning.isDuplicate ? 'bg-red-50 border-l-4 border-red-400' : ''
              ]"
          >
            <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
              {{ formatDate(planning.planningDate) }}
            </td>
            <td class="px-6 py-4 whitespace-nowrap">
              <div class="text-sm font-medium text-gray-900">{{ planning.employeeName || 'Unknown Employee' }}</div>
            </td>
            <td class="px-6 py-4 whitespace-nowrap">
              <div class="text-sm font-medium text-gray-900">
                {{ planning.orderNumber || `Order ${planning.orderId}` }}
                <span v-if="planning.isDuplicate" class="ml-2 text-xs bg-red-100 text-red-600 px-2 py-1 rounded">
                    ‚ö†Ô∏è Duplicate ({{ planning.duplicateCount }})
                  </span>
              </div>
              <div class="text-sm text-gray-500">{{ planning.cardCount || 0 }} cards</div>
            </td>
            <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
              {{ planning.startTime }} - {{ planning.endTime }}
            </td>
            <td class="px-6 py-4 whitespace-nowrap">
              <div class="text-sm font-medium text-gray-900">{{ formatDuration(planning.durationMinutes) }}</div>
              <div class="text-sm text-gray-500">
                {{ planning.cardCount || 0 }} cards √ó {{ CARD_PROCESSING_TIME }}min
              </div>
            </td>
            <td class="px-6 py-4 whitespace-nowrap">
                <span :class="[
                  'inline-flex px-2 py-1 text-xs font-semibold rounded-full',
                  planning.completed ? 'bg-green-100 text-green-800' : 'bg-yellow-100 text-yellow-800'
                ]">
                  {{ planning.completed ? 'Completed' : 'Pending' }}
                </span>
            </td>
            <td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
              <button
                @click="viewPlanningDetails(planning)"
                class="text-blue-600 hover:text-blue-900 mr-3"
              >
                View
              </button>
              <button
                @click="editPlanning(planning)"
                class="text-green-600 hover:text-green-900"
              >
                Edit
              </button>
            </td>
          </tr>
          </tbody>
        </table>
      </div>
    </div>

    <!-- Empty State -->
    <div v-else-if="!loading" class="bg-white rounded-lg shadow-md p-8 text-center">
      <svg class="mx-auto h-12 w-12 text-gray-400 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
      </svg>
      <h3 class="text-lg font-medium text-gray-900 mb-2">No plannings found</h3>
      <p class="text-gray-600 mb-4">Start by generating your first planning</p>
      <button
        @click="generatePlanning"
        class="btn-primary"
      >
        üöÄ Generate First Planning
      </button>
    </div>

    <!-- Loading State -->
    <div v-if="loading" class="bg-white rounded-lg shadow-md p-8 text-center">
      <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4"></div>
      <p class="text-gray-600">{{ loadingMessage || 'Loading plannings...' }}</p>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted } from 'vue'

// ========== CONSTANTS ==========
// Configuration from environment or default values
const CARD_PROCESSING_TIME = parseInt(import.meta.env.VITE_CARD_PROCESSING_TIME || '3') // minutes per card
const DEFAULT_WORK_HOURS = parseInt(import.meta.env.VITE_DEFAULT_WORK_HOURS || '8') // hours per day

console.log(`‚öôÔ∏è Configuration: ${CARD_PROCESSING_TIME}min per card, ${DEFAULT_WORK_HOURS}h per day`)

// ========== INTERFACES ==========
interface Planning {
  id: string
  orderId: string
  employeeId: string
  employeeName?: string
  orderNumber?: string
  planningDate: string
  startTime: string
  endTime: string
  durationMinutes: number
  cardCount?: number
  priority?: string
  status?: string
  completed: boolean
  notes?: string
}

interface PlanningConfig {
  startDate: string
  cardProcessingTime: number
  priorityMode: string
  redistributeOverload: boolean
  respectPriorities: boolean
}

// ========== STATE ==========
const loading = ref(false)
const generating = ref(false)
const optimizing = ref(false)
const loadingMessage = ref('')

const plannings = ref<Planning[]>([])

const config = ref<PlanningConfig>({
  startDate: getNextBusinessDay(),
  cardProcessingTime: CARD_PROCESSING_TIME, // Use environment variable
  priorityMode: 'urgent',
  redistributeOverload: true,
  respectPriorities: true
})

const stats = ref({
  totalOrders: 0,
  plannedOrders: 0,
  pendingOrders: 0,
  efficiency: 0,
  employeeCount: 0,
  duplicateCount: 0
})

// Computed for duplicate statistics
const duplicateStats = computed(() => {
  const duplicateGroups = new Map()

  plannings.value.forEach(planning => {
    const key = `${planning.orderNumber}_${planning.planningDate}_${planning.startTime}`
    if (!duplicateGroups.has(key)) {
      duplicateGroups.set(key, [])
    }
    duplicateGroups.get(key).push(planning)
  })

  const duplicateGroupsArray = Array.from(duplicateGroups.values()).filter(group => group.length > 1)
  const totalDuplicates = duplicateGroupsArray.reduce((sum, group) => sum + (group.length - 1), 0)

  return {
    duplicateGroups: duplicateGroupsArray.length,
    totalDuplicates
  }
})

// ========== COMPUTED ==========
const minDate = computed(() => {
  return new Date().toISOString().split('T')[0]
})

const groupedPlannings = computed(() => {
  const sorted = plannings.value.sort((a, b) => {
    const dateA = new Date(`${a.planningDate} ${a.startTime}`)
    const dateB = new Date(`${b.planningDate} ${b.startTime}`)
    return dateA.getTime() - dateB.getTime()
  })

  // Mark potential duplicates (same order at same time)
  const duplicateGroups = new Map()
  sorted.forEach(planning => {
    const key = `${planning.orderNumber}_${planning.planningDate}_${planning.startTime}`
    if (!duplicateGroups.has(key)) {
      duplicateGroups.set(key, [])
    }
    duplicateGroups.get(key).push(planning)
  })

  // Add isDuplicate flag
  return sorted.map(planning => {
    const key = `${planning.orderNumber}_${planning.planningDate}_${planning.startTime}`
    const group = duplicateGroups.get(key)
    return {
      ...planning,
      isDuplicate: group && group.length > 1,
      duplicateCount: group ? group.length : 1
    }
  })
})

// ========== METHODS ==========
function getNextBusinessDay(): string {
  const date = new Date()
  const day = date.getDay()

  // If it's Friday (5), Saturday (6), or Sunday (0), move to Monday
  if (day === 5) {
    date.setDate(date.getDate() + 3) // Friday + 3 = Monday
  } else if (day === 6) {
    date.setDate(date.getDate() + 2) // Saturday + 2 = Monday
  } else if (day === 0) {
    date.setDate(date.getDate() + 1) // Sunday + 1 = Monday
  } else if (day === 4) {
    date.setDate(date.getDate() + 4) // Thursday + 4 = Monday (skip weekend)
  } else {
    date.setDate(date.getDate() + 1) // Next day
  }

  return date.toISOString().split('T')[0]
}

const refreshData = async () => {
  await Promise.all([
    loadStats(),
    loadPlannings()
  ])
}

const loadStats = async () => {
  try {
    // Try multiple endpoints for stats
    const endpoints = [
      'http://localhost:8080/api/dashboard/stats',
      'http://localhost:8080/api/planning/stats',
      'http://localhost:8080/api/stats'
    ]

    for (const endpoint of endpoints) {
      try {
        const response = await fetch(endpoint)
        if (response.ok) {
          const data = await response.json()
          console.log(`‚úÖ Stats loaded from ${endpoint}:`, data)

          stats.value = {
            totalOrders: data.totalCommandes || data.totalOrders || 0,
            plannedOrders: data.commandesEnCours || data.plannedOrders || 0,
            pendingOrders: data.commandesEnAttente || data.pendingOrders || 0,
            efficiency: data.efficiency || 85,
            employeeCount: data.employesActifs || data.employeeCount || 0
          }
          break
        }
      } catch (error) {
        console.warn(`‚ö†Ô∏è ${endpoint} failed:`, error)
        continue
      }
    }
  } catch (error) {
    console.error('‚ùå Error loading stats:', error)
  }
}

const loadPlannings = async () => {
  loading.value = true
  loadingMessage.value = 'Loading plannings...'

  try {
    // Try multiple endpoints for plannings
    const endpoints = [
      'http://localhost:8080/api/planning/view-simple',
      'http://localhost:8080/api/planifications',
      'http://localhost:8080/api/planning',
      'http://localhost:8080/api/test/planifications'
    ]

    let rawPlannings = []

    for (const endpoint of endpoints) {
      try {
        console.log(`üîÑ Trying plannings endpoint: ${endpoint}`)
        const response = await fetch(endpoint)

        if (response.ok) {
          const data = await response.json()
          console.log(`‚úÖ Plannings loaded from ${endpoint}:`, data)

          if (Array.isArray(data)) {
            rawPlannings = data
            console.log(`üéØ Found ${rawPlannings.length} raw plannings`)
            break
          } else if (data.planifications && Array.isArray(data.planifications)) {
            rawPlannings = data.planifications
            console.log(`üéØ Found ${rawPlannings.length} raw plannings in wrapper`)
            break
          }
        }
      } catch (error) {
        console.warn(`‚ö†Ô∏è ${endpoint} failed:`, error)
        continue
      }
    }

    // Map and deduplicate plannings
    const mappedPlannings = rawPlannings.map(mapPlanning)

    // Remove duplicates based on unique combination of orderId + employeeId + date + time
    const uniquePlannings = []
    const seen = new Set()

    for (const planning of mappedPlannings) {
      const uniqueKey = `${planning.orderId}_${planning.employeeId}_${planning.planningDate}_${planning.startTime}`

      if (!seen.has(uniqueKey)) {
        seen.add(uniqueKey)
        uniquePlannings.push(planning)
      } else {
        console.warn(`üîÑ Duplicate planning filtered:`, {
          orderNumber: planning.orderNumber,
          employeeName: planning.employeeName,
          date: planning.planningDate,
          time: planning.startTime
        })
      }
    }

    plannings.value = uniquePlannings

    console.log(`üéØ Final plannings: ${rawPlannings.length} raw ‚Üí ${uniquePlannings.length} unique`)

    if (rawPlannings.length !== uniquePlannings.length) {
      const duplicatesRemoved = rawPlannings.length - uniquePlannings.length
      showNotification(`Loaded ${uniquePlannings.length} unique plannings (${duplicatesRemoved} duplicates filtered)`, 'success')
    } else {
      showNotification(`Loaded ${uniquePlannings.length} plannings`, 'success')
    }

  } catch (error) {
    console.error('‚ùå Error loading plannings:', error)
    showNotification('Error loading plannings', 'error')
  } finally {
    loading.value = false
    loadingMessage.value = ''
  }
}

const mapPlanning = (planningData: any): Planning => {
  // Calculate card count and duration
  const cardCount = planningData.cardCount || planningData.nombreCartes || planningData.cards_count || 0
  const calculatedDuration = cardCount > 0 ? cardCount * CARD_PROCESSING_TIME : (planningData.durationMinutes || planningData.dureeMinutes || planningData.duree_minutes || 60)

  return {
    id: planningData.id || `planning-${Date.now()}`,
    orderId: planningData.orderId || planningData.order_id || '',
    employeeId: planningData.employeeId || planningData.employe_id || '',
    employeeName: planningData.employeeName || planningData.employe_nom || planningData.employeFullName || 'Unknown Employee',
    orderNumber: planningData.orderNumber || planningData.numeroCommande || planningData.num_commande || `Order ${planningData.orderId}`,
    planningDate: planningData.planningDate || planningData.datePlanifiee || planningData.date_planification || new Date().toISOString().split('T')[0],
    startTime: planningData.startTime || planningData.heureDebut || planningData.heure_debut || '09:00',
    endTime: planningData.endTime || planningData.heureFin || planningData.heure_fin || calculateEndTime(planningData.startTime || '09:00', calculatedDuration),
    durationMinutes: calculatedDuration,
    cardCount,
    priority: planningData.priority || planningData.priorite || 'MEDIUM',
    status: planningData.status || planningData.statut || 'PENDING',
    completed: planningData.completed || planningData.terminee || false,
    notes: planningData.notes || `${cardCount} cards √ó ${CARD_PROCESSING_TIME}min = ${calculatedDuration}min`
  }
}

// Helper function to calculate end time based on start time and duration
const calculateEndTime = (startTime: string, durationMinutes: number): string => {
  try {
    const [hours, minutes] = startTime.split(':').map(Number)
    const startDate = new Date()
    startDate.setHours(hours, minutes, 0, 0)

    const endDate = new Date(startDate.getTime() + durationMinutes * 60000)

    return endDate.toTimeString().slice(0, 5) // Format HH:MM
  } catch (error) {
    // Fallback calculation
    const totalMinutes = durationMinutes + (parseInt(startTime.split(':')[0]) * 60) + parseInt(startTime.split(':')[1] || '0')
    const endHours = Math.floor(totalMinutes / 60) % 24
    const endMins = totalMinutes % 60
    return `${endHours.toString().padStart(2, '0')}:${endMins.toString().padStart(2, '0')}`
  }
}

const generatePlanning = async () => {
  if (generating.value) return

  generating.value = true
  loadingMessage.value = 'Generating planning...'

  try {
    console.log('üöÄ Generating planning with config:', config.value)

    // ‚úÖ CORRECTION: Mettre le GreedyPlanningService en PREMIER
    const endpoints = [
      'http://localhost:8080/api/planification-gloutonne/juin-2025',  // ‚úÖ Round-robin (Greedy)
      'http://localhost:8080/api/test/planification-simple',          // ‚úÖ Simple round-robin
      'http://localhost:8080/api/planifications/generate',            // ‚úÖ Smart distribution
      'http://localhost:8080/api/planning/generate'                   // ‚ùå Least busy (causait le probl√®me)
    ]

    let success = false

    for (const endpoint of endpoints) {
      try {
        console.log(`üîÑ Trying generate endpoint: ${endpoint}`)
        const response = await fetch(endpoint, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            startDate: config.value.startDate,
            timePerCard: config.value.cardProcessingTime,
            cleanFirst: false,
            priorityMode: config.value.priorityMode
          })
        })

        if (response.ok) {
          const result = await response.json()
          console.log(`‚úÖ Planning generated successfully with ${endpoint}:`, result)

          const planningsCreated = result.nombreCommandesPlanifiees || result.planningsSaved || result.count || 0
          showNotification(`Planning generated successfully! ${planningsCreated} orders planned`, 'success')

          // Reload plannings
          await loadPlannings()
          success = true
          break  // ‚úÖ Arr√™ter au premier succ√®s
        } else {
          console.warn(`‚ö†Ô∏è ${endpoint} failed with status:`, response.status)
        }
      } catch (error) {
        console.warn(`‚ö†Ô∏è ${endpoint} error:`, error)
        continue
      }
    }

    if (!success) {
      throw new Error('All planning generation endpoints failed')
    }

  } catch (error) {
    console.error('‚ùå Error generating planning:', error)
    showNotification('Error generating planning', 'error')
  } finally {
    generating.value = false
    loadingMessage.value = ''
  }
}

const optimizePlanning = async () => {
  optimizing.value = true
  loadingMessage.value = 'Optimizing planning...'

  try {
    // For now, just reload the data
    await loadPlannings()
    showNotification('Planning optimization completed', 'success')
  } catch (error) {
    console.error('‚ùå Error optimizing planning:', error)
    showNotification('Error optimizing planning', 'error')
  } finally {
    optimizing.value = false
    loadingMessage.value = ''
  }
}

const removeDuplicates = async () => {
  try {
    // Client-side duplicate removal (immediate)
    const originalCount = plannings.value.length
    const uniquePlannings = []
    const seen = new Set()

    for (const planning of plannings.value) {
      const uniqueKey = `${planning.orderId}_${planning.employeeId}_${planning.planningDate}_${planning.startTime}`

      if (!seen.has(uniqueKey)) {
        seen.add(uniqueKey)
        uniquePlannings.push(planning)
      }
    }

    plannings.value = uniquePlannings
    const duplicatesRemoved = originalCount - uniquePlannings.length

    if (duplicatesRemoved > 0) {
      showNotification(`Removed ${duplicatesRemoved} duplicate plannings`, 'success')

      // Try to clean duplicates on backend too
      try {
        await fetch('http://localhost:8080/api/planning/remove-duplicates', {
          method: 'POST'
        })
        console.log('‚úÖ Backend duplicates cleanup requested')
      } catch (backendError) {
        console.warn('‚ö†Ô∏è Backend duplicate cleanup failed:', backendError)
      }
    } else {
      showNotification('No duplicates found', 'success')
    }

  } catch (error) {
    console.error('‚ùå Error removing duplicates:', error)
    showNotification('Error removing duplicates', 'error')
  }
}

const cleanupData = async () => {
  if (!confirm('Are you sure you want to clean up old planning data?')) {
    return
  }

  try {
    // Try cleanup endpoint
    const response = await fetch('http://localhost:8080/api/planning/cleanup', {
      method: 'DELETE'
    })

    if (response.ok) {
      showNotification('Planning data cleaned up successfully', 'success')
      await loadPlannings()
    } else {
      throw new Error(`HTTP ${response.status}`)
    }
  } catch (error) {
    console.error('‚ùå Error cleaning up data:', error)
    showNotification('Error cleaning up data', 'error')
  }
}

// Debug function to test all planning endpoints
const testPlanningEndpoints = async () => {
  console.log('üîç === TESTING PLANNING ENDPOINTS ===')

  const endpoints = [
    { name: 'view-simple', url: 'http://localhost:8080/api/planning/view-simple' },
    { name: 'planifications', url: 'http://localhost:8080/api/planifications' },
    { name: 'planning', url: 'http://localhost:8080/api/planning' },
    { name: 'test-planifications', url: 'http://localhost:8080/api/test/planifications' },
    { name: 'dashboard-stats', url: 'http://localhost:8080/api/dashboard/stats' },
    { name: 'planification-gloutonne-test', url: 'http://localhost:8080/api/planification-gloutonne/test' }
  ]

  for (const endpoint of endpoints) {
    try {
      console.log(`üîÑ Testing: ${endpoint.url}`)
      const response = await fetch(endpoint.url)

      if (response.ok) {
        const data = await response.json()
        console.log(`‚úÖ ${endpoint.name} - SUCCESS:`, data)

        if (Array.isArray(data)) {
          console.log(`  üìä Array with ${data.length} items`)
          if (data.length > 0) {
            console.log(`  üìã First item structure:`, Object.keys(data[0]))
          }
        } else if (typeof data === 'object') {
          console.log(`  üìä Object with keys:`, Object.keys(data))
        }
      } else {
        console.log(`‚ùå ${endpoint.name} - FAILED: ${response.status}`)
      }
    } catch (error) {
      console.log(`‚ùå ${endpoint.name} - ERROR:`, error.message)
    }
  }

  console.log('üèÅ === ENDPOINT TESTING COMPLETE ===')
  showNotification('Check console for detailed endpoint test results', 'success')
}

const viewPlanningDetails = (planning: Planning) => {
  console.log('View planning details:', planning)
  // Implement details view
}

const editPlanning = (planning: Planning) => {
  console.log('Edit planning:', planning)
  // Implement edit functionality
}

const formatDate = (dateStr: string): string => {
  try {
    return new Date(dateStr).toLocaleDateString('en-US', {
      weekday: 'short',
      year: 'numeric',
      month: 'short',
      day: 'numeric'
    })
  } catch {
    return dateStr || 'Unknown date'
  }
}

const formatDuration = (minutes: number): string => {
  const hours = Math.floor(minutes / 60)
  const remainingMinutes = minutes % 60

  if (hours > 0) {
    return `${hours}h ${remainingMinutes}m`
  }
  return `${remainingMinutes}m`
}

// Simple notification function
const showNotification = (message: string, type: 'success' | 'error' | 'info' = 'success') => {
  console.log(`${type === 'success' ? '‚úÖ' : type === 'error' ? '‚ùå' : '‚ÑπÔ∏è'} ${message}`)
  // You can implement a real toast notification here
}

// ========== LIFECYCLE ==========
onMounted(() => {
  console.log('üìÖ Planning page mounted - Loading data...')
  refreshData()
})
</script>

<style scoped>
.planning-page {
  max-width: 1400px;
  margin: 0 auto;
  padding: 24px;
}

/* Loading spinner */
.animate-spin {
  animation: spin 1s linear infinite;
}

@keyframes spin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

/* Responsive design */
@media (max-width: 768px) {
  .planning-page {
    padding: 16px;
  }

  .grid-cols-1 {
    grid-template-columns: repeat(1, minmax(0, 1fr));
  }
}

@media (min-width: 768px) {
  .md\:grid-cols-3 {
    grid-template-columns: repeat(3, minmax(0, 1fr));
  }

  .md\:grid-cols-4 {
    grid-template-columns: repeat(4, minmax(0, 1fr));
  }
}
</style>
